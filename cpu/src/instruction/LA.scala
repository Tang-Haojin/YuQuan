package cpu.instruction

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._

import cpu.pipeline.LANumTypes._
import cpu.component.Operators._
import cpu.pipeline.ExecSpecials._
import cpu.pipeline.LAInstrTypes._
import cpu._

case class LA()(implicit val p: Parameters) extends CPUParams {
  private def JIRL   = BitPat("b010011_????????????????_?????_?????")
  private def BL     = BitPat("b01010?_????????????????_??????????") // we implement `B` as a pseudo instruction
  private def BEQ    = BitPat("b010110_????????????????_?????_?????")
  private def BNE    = BitPat("b010111_????????????????_?????_?????")
  private def BLT    = BitPat("b011000_????????????????_?????_?????")
  private def BGE    = BitPat("b011001_????????????????_?????_?????")
  private def BLTU   = BitPat("b011010_????????????????_?????_?????")
  private def BGEU   = BitPat("b011011_????????????????_?????_?????")
  private def AND    = BitPat("b00000000000101001_?????_?????_?????")
  private def ANDI   = BitPat("b0000001101_????????????_?????_?????")
  private def ADD    = BitPat("b00000000000100000_?????_?????_?????")
  private def ADDI   = BitPat("b0000001010_????????????_?????_?????")
  //private def LUI    = BitPat("b???????_?????_?????_???_?????_0110111")
  //private def AUIPC  = BitPat("b???????_?????_?????_???_?????_0010111")
  //private def JAL    = BitPat("b???????_?????_?????_???_?????_1101111")
  //private def JALR   = BitPat("b???????_?????_?????_000_?????_1100111")
  //private def BEQ    = BitPat("b???????_?????_?????_000_?????_1100011")
  //private def BNE    = BitPat("b???????_?????_?????_001_?????_1100011")
  //private def BLT    = BitPat("b???????_?????_?????_100_?????_1100011")
  //private def BGE    = BitPat("b???????_?????_?????_101_?????_1100011")
  //private def BLTU   = BitPat("b???????_?????_?????_110_?????_1100011")
  //private def BGEU   = BitPat("b???????_?????_?????_111_?????_1100011")
  //private def LB     = BitPat("b???????_?????_?????_000_?????_0000011")
  //private def LH     = BitPat("b???????_?????_?????_001_?????_0000011")
  //private def LW     = BitPat("b???????_?????_?????_010_?????_0000011")
  //private def LBU    = BitPat("b???????_?????_?????_100_?????_0000011")
  //private def LHU    = BitPat("b???????_?????_?????_101_?????_0000011")
  //private def SB     = BitPat("b???????_?????_?????_000_?????_0100011")
  //private def SH     = BitPat("b???????_?????_?????_001_?????_0100011")
  //private def SW     = BitPat("b???????_?????_?????_010_?????_0100011")
  //private def ADDI   = BitPat("b???????_?????_?????_000_?????_0010011")
  //private def SLTI   = BitPat("b???????_?????_?????_010_?????_0010011")
  //private def SLTIU  = BitPat("b???????_?????_?????_011_?????_0010011")
  //private def XORI   = BitPat("b???????_?????_?????_100_?????_0010011")
  //private def ORI    = BitPat("b???????_?????_?????_110_?????_0010011")
  //private def ANDI   = BitPat("b???????_?????_?????_111_?????_0010011")
  //private def SLLI   = 
  //        if(xlen!=32) BitPat("b000000?_?????_?????_001_?????_0010011")
  //        else         BitPat("b0000000_?????_?????_001_?????_0010011")
  //private def SRLI   = 
  //        if(xlen!=32) BitPat("b000000?_?????_?????_101_?????_0010011")
  //        else         BitPat("b0000000_?????_?????_101_?????_0010011")
  //private def SRAI   = 
  //        if(xlen!=32) BitPat("b010000?_?????_?????_101_?????_0010011")
  //        else         BitPat("b0100000_?????_?????_101_?????_0010011")
  //private def ADD    = BitPat("b0000000_?????_?????_000_?????_0110011")
  //private def SUB    = BitPat("b0100000_?????_?????_000_?????_0110011")
  //private def SLL    = BitPat("b0000000_?????_?????_001_?????_0110011")
  //private def SLT    = BitPat("b0000000_?????_?????_010_?????_0110011")
  //private def SLTU   = BitPat("b0000000_?????_?????_011_?????_0110011")
  //private def XOR    = BitPat("b0000000_?????_?????_100_?????_0110011")
  //private def SRL    = BitPat("b0000000_?????_?????_101_?????_0110011")
  //private def SRA    = BitPat("b0100000_?????_?????_101_?????_0110011")
  //private def OR     = BitPat("b0000000_?????_?????_110_?????_0110011")
  //private def AND    = BitPat("b0000000_?????_?????_111_?????_0110011")
  //private def FENCE  = BitPat("b???????_?????_?????_000_?????_0001111")
  //private def ECALL  = BitPat("b0000000_00000_00000_000_00000_1110011")
  //private def EBREAK = BitPat("b0000000_00001_00000_000_00000_1110011")
//
  //private def LWU    = BitPat("b???????_?????_?????_110_?????_0000011")
  //private def LD     = BitPat("b???????_?????_?????_011_?????_0000011")
  //private def SD     = BitPat("b???????_?????_?????_011_?????_0100011")
  //private def ADDIW  = BitPat("b???????_?????_?????_000_?????_0011011")
  //private def SLLIW  = BitPat("b000000?_?????_?????_001_?????_0011011")
  //private def SRLIW  = BitPat("b000000?_?????_?????_101_?????_0011011")
  //private def SRAIW  = BitPat("b010000?_?????_?????_101_?????_0011011")
  //private def ADDW   = BitPat("b0000000_?????_?????_000_?????_0111011")
  //private def SUBW   = BitPat("b0100000_?????_?????_000_?????_0111011")
  //private def SLLW   = BitPat("b0000000_?????_?????_001_?????_0111011")
  //private def SRLW   = BitPat("b0000000_?????_?????_101_?????_0111011")
  //private def SRAW   = BitPat("b0100000_?????_?????_101_?????_0111011")
//
  //private def TRAP   = BitPat("b???????_?????_?????_???_?????_1101011")

  val table = List(
    //           |Type|num1 |num2 |num3 |num4 |op1_2| WB |Special|
    JIRL  -> List(i16 , rj  , four, imm , non , add , 1.B, norm  ),
    BL    -> List(i26 , pc  , four, non , non , add , 1.B, norm  ),
    BEQ   -> List(i16 , rj  , rd  , imm , non , nop , 0.B, norm  ),
    BNE   -> List(i16 , rj  , rd  , imm , non , nop , 0.B, norm  ),
    BLT   -> List(i16 , rj  , rd  , imm , non , nop , 0.B, norm  ),
    BGE   -> List(i16 , rj  , rd  , imm , non , nop , 0.B, norm  ),
    BLTU  -> List(i16 , rj  , rd  , imm , non , nop , 0.B, norm  ),
    BGEU  -> List(i16 , rj  , rd  , imm , non , nop , 0.B, norm  ),
    AND   -> List(r3  , rj  , rk  , non , non , and , 1.B, norm  ),
    ANDI  -> List(i12 , rj  , imm , non , non , and , 1.B, norm  ),
    ADD   -> List(r3  , rj  , rk  , non , non , add , 1.B, norm  ),
    ADDI  -> List(i12 , rj  , imm , non , non , add , 1.B, norm  )
    // LUI   -> List(u   , non , imm , non , non , add , 1.B, norm  ),
    // AUIPC -> List(u   , pc  , imm , non , non , add , 1.B, norm  ),
    // JAL   -> List(j   , pc  , four, imm , non , add , 1.B, norm  ),
    // JALR  -> List(i   , pc  , four, imm , non , add , 1.B, norm  ),
    // BEQ   -> List(b   , rs1 , rs2 , imm , non , nop , 0.B, norm  ),
    // BNE   -> List(b   , rs1 , rs2 , imm , non , nop , 0.B, norm  ),
    // BLT   -> List(b   , rs1 , rs2 , imm , non , nop , 0.B, norm  ),
    // BGE   -> List(b   , rs1 , rs2 , imm , non , nop , 0.B, norm  ),
    // BLTU  -> List(b   , rs1 , rs2 , imm , non , nop , 0.B, norm  ),
    // BGEU  -> List(b   , rs1 , rs2 , imm , non , nop , 0.B, norm  ),
    // LB    -> List(i   , non , non , rs1 , imm , nop , 1.B, ld    ),
    // LH    -> List(i   , non , non , rs1 , imm , nop , 1.B, ld    ),
    // LW    -> List(i   , non , non , rs1 , imm , nop , 1.B, ld    ),
    // LBU   -> List(i   , non , non , rs1 , imm , nop , 1.B, ld    ),
    // LHU   -> List(i   , non , non , rs1 , imm , nop , 1.B, ld    ),
    // SB    -> List(s   , rs2 , non , rs1 , imm , add , 0.B, st    ),
    // SH    -> List(s   , rs2 , non , rs1 , imm , add , 0.B, st    ),
    // SW    -> List(s   , rs2 , non , rs1 , imm , add , 0.B, st    ),
    // ADDI  -> List(i   , rs1 , imm , non , non , add , 1.B, norm  ),
    // SLTI  -> List(i   , rs1 , imm , non , non , lts , 1.B, norm  ),
    // SLTIU -> List(i   , rs1 , imm , non , non , ltu , 1.B, norm  ),
    // XORI  -> List(i   , rs1 , imm , non , non , xor , 1.B, norm  ),
    // ORI   -> List(i   , rs1 , imm , non , non , or  , 1.B, norm  ),
    // ANDI  -> List(i   , rs1 , imm , non , non , and , 1.B, norm  ),
    // SLLI  -> List(i   , rs1 , imm , non , non , sll , 1.B, norm  ),
    // SRLI  -> List(i   , rs1 , imm , non , non , srl , 1.B, norm  ),
    // SRAI  -> List(i   , rs1 , imm , non , non , sra , 1.B, norm  ),
    // ADD   -> List(r   , rs1 , rs2 , non , non , add , 1.B, norm  ),
    // SUB   -> List(r   , rs1 , rs2 , non , non , sub , 1.B, norm  ),
    // SLL   -> List(r   , rs1 , rs2 , non , non , sll , 1.B, norm  ),
    // SLT   -> List(r   , rs1 , rs2 , non , non , lts , 1.B, norm  ),
    // SLTU  -> List(r   , rs1 , rs2 , non , non , ltu , 1.B, norm  ),
    // XOR   -> List(r   , rs1 , rs2 , non , non , xor , 1.B, norm  ),
    // SRL   -> List(r   , rs1 , rs2 , non , non , srl , 1.B, norm  ),
    // SRA   -> List(r   , rs1 , rs2 , non , non , sra , 1.B, norm  ),
    // OR    -> List(r   , rs1 , rs2 , non , non , or  , 1.B, norm  ),
    // AND   -> List(r   , rs1 , rs2 , non , non , and , 1.B, norm  )) ++ (if (!isZmb) List(
    // FENCE -> List(i   , non , non , non , non , nop , 0.B, norm  ), // do nothing
    // ECALL -> List(i   , non , non , non , non , nop , 0.B, ecall ),
    // EBREAK-> List(i   , non , non , non , non , nop , 0.B, ebreak)) else Nil) ++ (if (Debug) List(
    // TRAP  -> List(i   , rs1 , non , non , non , nop , 0.B, trap  )) else Nil) ++ (if (xlen != 32) List(
    // LWU   -> List(i   , non , non , rs1 , imm , nop , 1.B, ld    ),
    // LD    -> List(i   , non , non , rs1 , imm , nop , 1.B, ld    ),
    // SD    -> List(s   , rs2 , non , rs1 , imm , add , 0.B, st    ),
    // ADDIW -> List(i   , rs1 , imm , non , non , add , 1.B, word  ),
    // SLLIW -> List(i   , rs1 , imm , non , non , sllw, 1.B, word  ),
    // SRLIW -> List(i   , rs1 , imm , non , non , srlw, 1.B, word  ),
    // SRAIW -> List(i   , rs1 , imm , non , non , sraw, 1.B, word  ),
    // ADDW  -> List(r   , rs1 , rs2 , non , non , add , 1.B, word  ),
    // SUBW  -> List(r   , rs1 , rs2 , non , non , sub , 1.B, word  ),
    // SLLW  -> List(r   , rs1 , rs2 , non , non , sllw, 1.B, word  ),
    // SRLW  -> List(r   , rs1 , rs2 , non , non , srlw, 1.B, word  ),
    // SRAW  -> List(r   , rs1 , rs2 , non , non , sraw, 1.B, word  )) else Nil
  )
}
